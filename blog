#!/usr/bin/perl -s-
use strict;
use warnings;

use lib '/Users/rjbs/bin/';
our $p;

my $queue = "/Users/rjbs/tmp/blog/";

unless ($p) { # new entry 
	my $fn = $queue . time . ".txt";

	system("vi",'-S','~/.vim/blog.vim', $fn);
}

foreach my $file (glob("${queue}*")) {
	unless ((stat $file)[7]) {
		unlink $file or die "can't remove $file: $!";
		print "removing empty $file\n";
		next;
	}
	next if $file =~ /^\./;
	exit unless -r $file;

	my $entry_text; { open my $in, '<', $file; local $/; $entry_text = <$in>; }
	exit unless $entry_text;

	# my @messages = split /\s*^\.\n\s*/ms, $entry_text;
  my @messages = $entry_text;
	my $errors;

	POST: foreach my $message (@messages) {
		use Email::Simple;
		my $entry = Email::Simple->new($message);

		my %document = map { $_ => scalar $entry->header($_) }
                   qw(title subtitle tags uri);
		($document{body} = $entry->body);

    unless ($document{tags} =~ /\@markup:md/) {
      $document{body} =~ s/(?<![\t\n])\n(?![\t\n])/ /smg;
    }

    my %journal = (
      rubric  => 'PostRubric',
      useperl => 'UsePerl',
    );

    if ($entry->header('on-hold')) {
      print "skipping message $file, on-hold header set\n";
      $errors++;
      next POST;
    }

    my @post_to;
    if (my $post_to = $entry->header("post-to")) {
      @post_to = split /\s+/, $post_to;
    } else {
      @post_to = keys %journal;
    }

		eval {
      for (@post_to) {
        eval "require $journal{$_}" or die $@;
        $journal{$_}->add_entry(\%document);
      }
		};
    if ($@) { $errors++; warn $@; }
	}

	if ($errors) { print "can't post $file now\n"; }
	else         { unlink $file;                   }
}
